import networkx as nx
import NetworkX_edited as nxe
import math

def distance_euclidean(coordinates, i, j):       
    squares = tuple(map(lambda x, y: (x - y) ** 2, coordinates[i], coordinates[j]))
    return math.sqrt(sum(squares))

def graph_efficiency(G_orig, removed_node=None):
    """ A network graph is considered efficient if the the weighted length of the shortest paths is close to the Euclidean distance 
    i.e. "The street network of a city is efficient if driving by car along the edges (streets) is almost as fast as flying non-stop from start node to end node."
    removed_node allows to calculate the Graph efficiency while simulate the disconnection of one particular node. 
    The graph G requires each node to have an attribute 'coord' which is a tuple (x,y) with this node's (real-world) Cartesian coordinates.
    """
    if removed_node:
        G = G_orig.copy()
        G.remove_node(removed_node)
    else:
        G = G_orig
    all_coordinates = nx.get_node_attributes(G, 'coord') # a key-value set with the coordinates of each node
    sum1 = 0
    for i in G:
        shortest_length_set = nx.single_source_dijkstra_path_length(G, i)
        for j in G:
            if i < j:
                a = distance_euclidean(all_coordinates, i, j) # the Euclidean distance between nodes i and j along a straight line
                b = shortest_length_set[j] # the shortest path length between i and j
                sum1 += a / b    
    return sum1 / (len(G) * (len(G) - 1) / 2)

def pointwise_vulnerability(G, node_removed):
    """
    This is an alias. See function 'information_centrality(G, node_removed)'.
    """
    return information_centrality(G, node_removed)

def information_centrality(G, node_removed):
    """ 
    Returns the vulnerability score for a given node. This score represents the relative drop in the Euclidean Network Efficiency caused by removing 'node_removed'.
    The graph G requires each node to have an attribute 'coord' which is a tuple (x,y) with this node's (real-world) Cartesian coordinates.
    """
    a = graph_efficiency(G)
    b = graph_efficiency(G, node_removed)
    return (a - b) / a

def global_vulnerability(G):
    """ 
    Returns a list of nodes and their vulnerability score, sorted most vulnerable first.
    The graph G requires each node to have an attribute 'coord' which is a tuple (x,y) with this node's (real-world) Cartesian coordinates.
    """
    a = graph_efficiency(G)
    c = []
    for i in G:
        b = graph_efficiency(G, i)       
        c.append({'node': i, 'vuln' : (a - b) / a})
    return sorted(c, key=lambda k: k['vuln'], reverse = True) 
